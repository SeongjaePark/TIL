# 5. 메모리

[Naver BoostCourse CS50 2019](https://www.edwith.org/boostcourse-cs-050)

<details>
  <summary>1) 메모리 주소</summary>

# 학습 목표

16진법을 읽고 쓸 수 있다.

메모리 주소에 접근하고 값을 받아오는 코드를 C로 작성할 수 있다.

# 16진수

컴퓨터과학에서는 숫자를 10진수나 2진수 대신 **16진수(Hexadecimal)**로 표현하는 경우가 많다. 컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문이다.

16진수와 일상생활에서 우리가 사용하는 10진수를 비교하면 그 차이를 알 수 있다. 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다. 16진수로 값을 표현하는 방법을 이해하고 나면 16진수, 2진수, 10진수를 변환하는 프로그램을 만들어볼 수 있다.

# 10진수를 16진수로 바꿔 보기

JPG 이미지 파일은 항상 255 216 255 로 시작되고 이것은 10진수이다. 하지만 실제 컴퓨터 내에서는 10진수를 사용하지 않는다. 컴퓨터는 0과 1만을 이해할 수 있기 때문이다.

<img src="imgs/memoryAddress1.png" width="400">

먼저 255 215 255를 2진수를 나타내보면 위의 그림과 같다. 2진수로 모든 데이터를 표현하기에는 너무 길어지기 때문에 16진수로 바꾸면 **2^4이 16이기 때문에 4bits씩** 두 덩어리로 나누어 보면 0000부터 1111까지는 16진수로 표현할 수 있다는 것을 알 수 있다.

그렇다면 16진수에서 10부터 15까지는 어떻게 표기할까? 10은 a, 11은 b, ..., 15는 f를 대입하여 사용한다. 4bits씩 15진수로 변환 후 **0x**를 붙여 뒤에 오는 문자들이 16진수임을 알려 준다.

# 16진수의 유용성

ASCII 코드에 의해 "A, B, C"는 10진수로 65, 66, 67에 해당한다. 컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해보면 "01000001 01000010 01000011"이 된다. 컴퓨터가 처리할 수 있어야 하기에 어쩔 수 없지만 그 길이가 너무 긴 것을 알 수 있다.

하지만 16진수로 표현하면 2진수로 표현했을 때보다 훨씬 간단해진다. 또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현한다. **2개의 16진수는 1byte의 2진수로 변환**되기 때문에 정보를 표현하기 매우 유용하다.

<img src="imgs/memoryAddress2.png" width="400">

# 메모리 주소

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 생각해 보자.

이 n이라는 값은 **int** 타입이므로, 아래 그림과 같이 우리 컴퓨터의 메모리 어딘가에 **4바이트** 만큼의 자리를 차지하며 저장되어 있을 것이다.

<img src="imgs/memoryAddress3.png" width="400">

C에서는 변수의 **메모리상 주소**를 받기 위해 '**&**'이라는 연산자를 사용할 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```

예를 들어, 위와 같은 코드를 실행하면 '0x7ffef009b75c'와 같은 값을 얻을 수 있고, 이는 변수 n의 **16진법**으로 표현된 메모리의 주소이다.

반대로 '**\***'를 사용하면 그 메모리 주소에 있는 **실제 값**을 얻을 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```

위 코드는 먼저 **n의 주소**를 얻고, 또 다시 **그 주소에 해당하는 값**을 얻어와 출력한 것이므로 결국 '50'이라는 값이 출력된다.

# 생각해보기

'CS50'을 16진수로 표현해보자

- ASCII코드 기준 CS50의 값은 10진수로 각각 67 83 53 48 이다
- 따라서 16진수로 표현하면 43 53 35 30 이다

</details>

<details>
  <summary>2) 포인터</summary>

# 학습하기

포인터 변수를 정의하고 사용할 수 있다.

# 포인터

지난 파트에서 배웠던 '\*' 연산자는 어떤 메모리 주소에 있는 값을 받아오게 해준다.

이 연산자를 이용해서 **포인터 역할을 하는 변수**를 선언할 수도 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    int *p = &n;
    printf("%p\n", p);
    printf("%i\n", *p);
}
```

위 코드를 보면 정수형 변수 n에는 50이라는 값이 저장되어 있다.

그리고 **\*p**라는 **포인터 변수**에 &n이라는 값, 즉 **변수 n의 주소**를 저장한다.

int *p에서 p앞의 *는 이 변수가 포인터라는 의미이고, int는 이 포인터가 int 타입의 변수를 가리킨다는 의미이다.

따라서 첫 번째 printf문과 같이 포인터 p의 값, 즉 변수 **n의 주소를 출력**하거나, 두 번째 printf문과 같이 포인터 **p가 가리키는 변수의 값**, 즉 변수 n의 값을 출력할 수도 있다.

실제 컴퓨터 메모리에서 변수 p는 아래와 같이 저장될 수 있다.

<img src="imgs/pointer1.png" width="400">

하지만 아래 그림과 같이 실제로 p의 값, 즉 n의 주소 값을 생각하지 않고, 추상적으로 단지 **p가 n을 가리키고 있다는 것**만 생각해도 된다.

<img src="imgs/pointer2.png" width="400">

이런 포인터를 기반으로 해서 앞으로 배울 다양한 데이터 구조를 정의하고 사용할 수 있다.

# 생각해보기

포인터의 크기는 메모리의 크기와 어떤 관계가 있을까?

- 컴퓨터에 있는 메모리의 크기가 크면 각각의 메모리 주소를 표현하는 숫자 또한 커지기 때문에 포인터의 크기도 커질 것 같다.

</details>

<details>
  <summary>3) 문자열</summary>

</details>

<details>
  <summary>4) 문자열 비교</summary>

</details>

<details>
  <summary>5) 문자열 복사</summary>

</details>

<details>
  <summary>6) 메모리 할당과 해제</summary>

</details>

<details>
  <summary>7) 메모리 교환, 스택, 힙</summary>

</details>

<details>
  <summary>8) 파일 쓰기</summary>

</details>

<details>
  <summary>9) 파일 읽기</summary>

</details>

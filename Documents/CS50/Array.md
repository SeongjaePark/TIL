# 3. 배열

[Naver BoostCourse CS50 2019](https://www.edwith.org/boostcourse-cs-050)

<details>
  <summary>1) 컴파일링</summary>

# 학습 목표

컴파일링의 네 단계를 설명할 수 있다.

# 컴파일링

지금까지는 아무것도 모른 채 마구잡이로 쓴 코드가 잘 돌아갔다면 이제부터는 연습과 응용을 통해 동작 원리를 이해할 수 있을 것이다.

우선 첫 수업에 봤던 예제를 다시 살펴보며 지금 사용하는 방법이 그때 우리가 사용한 방법과 어떻게 다른지 알아보자.

```c
#include <stdio.h>

int main(void)
{
    printf("hello, world\n");
}
```

우선 main이라는 함수가 있었다. 프로그램의 시작점으로써 **실행 버튼을 클릭**하는 것과 같다.

printf는 출력을 담당하는 함수이다. printf 함수를 사용하기 위해서는 stdio.h 라이브러리가 필요하다.

정확히 말하면 stdio.h는 헤더 파일로 C언어로 작성되어 있으며 파일명이 .h로 끝나는 파일이다.

이 파일에는 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일할 때 printf가 무엇인지 알려주는 역할을 한다.

코드를 `clang hello.c`로 컴파일하고 `./a.out` 명령으로 프로그램을 실행할 때 이 과정은 컴퓨터가 이해하는 0과 1로 가득찬 파일 a.out을 생성하며 실행 가능하게 한다.

이해하기 어려운 이 과정에 대한 이해는 잠시 미뤄두고 우선 넘어가보도록 하자.

만약 a.out과 다른 이름(hello)으로 컴파일을 하고 싶다면 아래와 같이 명령행 인자를 추가해줘야 한다.

`clang -o hello hello.c`

또한 우리는 CS50 라이브러리를 사용해 보았다.

이처럼 CS50 라이브러리를 사용한 프로그램을 컴파일 할 때는 clang에 또 하나의 프로그램(-lcs50)이 필요했다. 그래야 clang이 실행되었다.

`clang -o hello hello.c -lcs50`

이는 clang에게 CS50 라이브러리에 있는 모든 0과 1들을 여기에 연결하라는 의미이다.

더 간단히는, 이전에 배웠듯이 make 프로그램을 이용하면 이 모든 컴파일 과정을 자동으로 처리할 수 있다. make나 clang을 사용해서 프로그램을 실행할 때 아래 네 개의 단계를 거친다.

- 전처리(Preprocessing)
- 컴파일링(Compiling)
- 어셈블링(Assembling)
- 링킹(Linking)

우리가 명령어를 실행할 때 정확히 어떤 일이 일어나는지 알아보도록 하자.

## 전처리(Precompile)

**컴파일의 전체 과정은 네 단계로 나누어볼 수 있다**. 그 중 첫 번째 단계는 **전처리**인데, 전처리기에 의해 수행된다. #으로 시작되는 C 소스코드는 전처리기에게 **실질적인 컴파일이 이루어지기 전에 무언가를 실행**하라고 알려준다.

예를 들어, #include는 전처리기에게 다른 파일의 내용을 포함시키라고 알려준다. 프로그램의 소스 코드에 #include와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스코드 형태이며 stdio.h 파일의 내용이 #include 부분에 포함된다.

## 컴파일(Compile)

전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 **컴파일**이다. **컴파일러**라고 불리는 프로그램은 **C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일**한다.

**어셈블리**는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있다. C코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램을 만들어 준다. 컴파일이라는 용어는 소스 코드에서 오브젝트 코드(머신 코드, 기계어)로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 한다.

## 어셈블(Assemble)

소스 코드가 어셈블리 코드로 변환되면, 다음 단계는 **어셈블** 단계로 **어셈블리 코드를 오브젝트 코드로 변환**시키는 것이다. 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 **연속된 0고 1들로 바꿔주는 작업**이다. 이 변환 작업은 **어셈블러**라는 프로그램이 수행한다. 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 난다. 그러나 그렇지 않은 경우에는 링크라 불리는 단계가 추가된다.

## 링크(Link)

만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) **여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 *링크*라는 컴파일의 마지막 단계가 필요하다.** 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다. 예를 들어, 컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 `GetInt()`나 `GetString()` 같은 함수를 어떻게 실행할 지 알 수 있게 된다.

이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.

# 생각해보기

만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까?

- 단순한 목적을 달성하기 위해서도 프로그래밍을 하는 데에 투자해야 하는 시간과 노력이 클 것이다.
- 즉, 원하는 목적 그 자체를 이루는 것에 집중하기 힘들 수 있다.

</details>

<details>
  <summary>2) 디버깅</summary>

</details>

<details>
  <summary>3) 코드의 디자인</summary>

</details>

<details>
  <summary>4) 배열(1)</summary>

</details>

<details>
  <summary>5) 배열(2)</summary>

</details>

<details>
  <summary>6) 문자열과 배열</summary>

</details>

<details>
  <summary>7) 문자열의 활용</summary>

</details>

<details>
  <summary>8) 명령행 인자</summary>

</details>

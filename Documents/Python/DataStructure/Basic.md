# 1. 기본적인 자료구조

[코드잇 자료구조 ](https://www.codeit.kr/courses/data-structures)

<details>
  <summary>1) 컴퓨터가 데이터를 저장하는 법</summary>

  <details>
    <summary> 스토리지 Vs 메모리</summary>

# 스토리지 Vs 메모리

자료 구조

- 목적: 자료를 구조화 → 데이터를 효율적으로 사용
- 컴퓨터에 데이터가 어떻게 저장되는지 알아야 됨!

데이터 저장

- **스토리지**: 데이터가 영구적으로 저장되는 곳
  - 데이터를 저장하는 데 오래 걸림
  - 데이터를 받아오는 데 오래 걸림
- **메모리**: 데이터가 **임시**로 저장되는 곳
  - 데이터를 저장이 빠르다
  - 데이터를 받아오기가 빠르다

왜 따로 필요?

- 스토리지는 용량이 크기 때문에 스토리지에 저장해 놓고, 필요할 때 메모리에 올려놓고 사용
  - 영화를 볼 때, 파일을 실행하면 매 장면을 실시간으로 스토리지에서 받아오면 느리기 때문에 메모리에 복사해놓고 메모리로부터 받아오면 빠름. 대신 영화를 끄면 메모리에 있는 영화 데이터는 지워지고 스토리지에만 남게 됨

자료구조에서 중요한 것은 메모리.

결국 자료구조는 데이터를 메모리에서 잘 사용하도록 하는 것이 목적임

  </details>

  <details>
    <summary> RAM</summary>

# RAM: Random Access Memory

### 메모리

- 일정한 칸으로 나눠져 있음
- 각 칸에 데이터를 저장할 수 있음
- 각 칸은 자신만의 주소가 있음

### RAM: 임의 접근 메모리

- 임의 접근: 저장 위치를 알면 접근할 때 항상 일정한 시간이 걸림
  - 메모리에 저장한 데이터 접근 시간 복잡도: O(1)
- 순차 접근: 저장된 위치까지 가는 데 한 단계씩 거쳐야 됨 (예: 비디오 테이프)
- 임의 접근이 순차 접근보다 효율적!

메모리는 **임의 접근**으로 동작하고 있다는 것을 늘 기억하고 있어야 한다.

  </details>
  
  <details>
    <summary>메모리의 기본 단위:</summary>

# 메모리의 기본 단위: 바이트

메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위는 1**바이트(byte) = 8비트(bit)**.

바이트가 아닌 다른 크기의 용량을 담는 저장 장치들도 있지만, 대부분의 현대 컴퓨터 시스템들은 메모리 한 칸에 바이트만큼의 데이터를 저장함

1. 바이트는 컴퓨터 저장 공간 용량을 나타내는 단위
2. 메모리 한 칸에 담기는 데이터 용량은 1 바이트

  </details>

  <details>
    <summary>레퍼런스</summary>

# 레퍼런스

### 레퍼런스(reference)

- 데이터에 접근할 수 있게 해주는 값
- "주소"보다 조금 더 포괄적인 표현 (주소 자체가 항상 레퍼런스인 것은 아님)
- 자료 구조를 공부할 때는 주소와 레퍼런스를 비슷하게 생각해도 무방

### 변수를 사용할 때

```python
x = 95
print(x + 5) -> #print(95 + 5)
```

x에 정수 95가 아니라, 레퍼런스가 담겨 있음

레퍼런스에 5를 더하는 것이 아니라,  
**실제로 변수를 사용할 때는 저장된 값을 알아서 받아옴**

  </details>

  <details>
    <summary>데이터의 주소</summary>

# 데이터의 주소

### 파이썬 id() 함수

데이터가 저장되어 있는 주소를 알아내는 방법

`id()` 함수를 이용하면 저장된 데이터의 메모리 주소를 정수로 표현한 값을 알아낼 수 있다.

여러 타입의 데이터를 저장하고 `id()` 함수를 써서 메모리 주소를 출력시켜 보자.

```python
# 여러 데이터를 저장한다.
list1 = [1, 2]
int1 = 0
float1 = 3.14
set1 = set()
tuple1 = (2, 3)

# 저장된 데이터의 메모리 저장 위치를 받아온다.
print(id(list1)) # 140691582428864
print(id(int1)) # 140691591012576
print(id(float1)) # 140691582327216
print(id(set1)) # 140691580568064
print(id(tuple1)) # 140691582524544
```

데이터가 각각 다른 메모리 주소에 저장되어 있는 것을 확인할 수 있다.

### 같은 주소에 저장되어 있는 데이터

당연한 말이지만, 똑같은 주소에 저장되어 있는 데이터는 똑같은 데이터이다.

```python
# 리스트를 정의한다
list1 = [1, 2]
list3 = [1, 2, 3]

# Aliasing을 통해 list1과 list2를 같게 한다
list2 = list1

# 두 데이터의 메모리를 출력한다
print(id(list1)) # 140618457056960
print(id(list2)) # 140618457056960
print(id(list3)) # 140618457057344

```

메모리에서 만든 하나의 같은 리스트를 list1, list2라는 두 개의 다른 변수가 가리키고 있다.

이렇게 여러 변수가 같은 메모리를 가리키는 것을 **Aliasing**이라고 한다.

`id()` 함수를 써서 메모리 주소를 출력해보면, list1과 list2는 서로 같은 리스트를 가리키고 있기 때문에 똑같은 메모리 주소가 출력되고, list3는 전혀 다른 리스트를 가리키고 있기 때문에 다른 메모리 주소가 출력된다.

  </details>

</details>

<details>
  <summary>2) 배열</summary>

  <details>
    <summary>배열이란</summary>

# 배열이란

파이썬 리스트는 C 언어의 배열을 이용해 만들어졌음

### C 배열

- 크기가 고정돼 있다
- 같은 타입의 데이터만 담을 수 있다
- 값 자체를 저장
- 데이터가 메모리에 연속적으로 저장

### 파이썬 리스트

- 크기가 유동적이다
- 다양한 타입의 데이터를 담을 수 있다
- 레퍼런스를 저장

  </details>
  <details>
  <summary>배열 인덱스를 이용한 데이터 저장/접근법</summary>

# 배열 인덱스를 이용한 데이터 저장/접근법

### 정수형 값 4개를 저장하는 C 배열 정의

```c
//정수형 값 하나의 크기 = 4 바이트

int numArray[4]; //사용하고 있지 않은 **연속**적인 16칸 예약
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
// 배열의 요소들이 메모리에 순서대로 그리고 연속적으로 저장 됨
```

저장된 데이터를 받아오는 건 저장할 때처럼 그냥 인덱스를 사용하면 됨

인덱스 i의 주소: 시작주소 + 데이터 크기 x 인덱스

- ex) 배열의 시작주소가 1000이고, 정수형 배열인 경우의 주소: 1000 + 4 x i

### 배열 인덱스 접근과 저장의 시간복잡도

이처럼 배열의 값을 가져오려면 그 값의 주소를 알아야 함

그 주소는 그냥 간단한 계산으로 알 수 있음

따라서 임의 접근이기 때문에 배열에서 값을 받아오는 건 **O(1)**으로 할 수 있음

값을 저장하는 것도 마찬가지. 주소를 계산해서 그 주소에 O(1)으로 접근하고 거기에 값을 저장하면 되는 것임

  </details>

  <details>
    <summary>배열 탐색</summary>

# 배열 탐색

### 접근과 탐색

- 접근: 인덱스를 통해 값을 찾는 것
- 탐색: 특정 조건을 만족하는 값을 찾는 것

### 선형 탐색

- 값이 존재하는지 첫번째 인덱스부터 시작해서 찾을때까지 쭈욱 확인하는 방법
- 배열이 정렬되어 있지 않은 이상 사실상 이 방법보다 효율적으로 탐색할 수는 없음
- 시간 복잡도: O(n)

### 정리

- 배열 접근 연산: O(1)
- 배열 탐색 연산: O(n)
  </details>

  <details>
    <summary>정적 & 동적 배열</summary>

# 정적 배열

### 배열

- 정적 배열: 크기 고정 (요소 수 제한)
- 동저 배열: 크기 변함 (요소 계속 추가 가능)

보통 배열이라고 할 때에는 정적 배열을 뜻하고, 동적 배열은 '동적' 배열이라고 확실히 표현

모든 주소에 값이 있는 정적 배열에서 배열에 새로운 요소를 추가하려면 새로운 배열로 복사하고 그 뒤에 값을 추가해야 함

그렇다고 배열에 미리 너무 많은 메모리를 할당하면 메모리를 쓸데없이 낭비하게 됨

# 동적 배열 (Dynamic Array)

- 정적 배열로 만들어진 자료 구조
- 정적 배열의 크기를 상황에 맞게 조절한다.
  - ex) 기존 배열이 꽉 찼을 때 배열의 크기를 2배로 늘려주면 한 동안 늘려줄 필요가 없다
  </details>
  <details>
    <summary>파이썬 리스트의 비밀</summary>

# 파이썬 리스트(동적 배열)의 비밀

파이썬은 C를 통해 구현된 언어로, 파이썬의 리스트는 내부적으로 C 배열을 이용해서 만들어짐

`int_list = [2, 3, 5, 7, 11]`

우리 입장에서 내부적으로 얼마나 큰 배열이 있는지 몰라도, 값을 마음대로 추가할 수 있다. 동적 배열이기 때문에 상화에 맞게 배열의 크기가 조절되고 있는 것

`int_list.append(13)`

그런데 우리는 내부적으로 얼마나 큰 배열이 있는지 모른다. 아무리 저장한 데이터가 6개여도 내부적으로는 8개짜리 배열일 수도 있고, 12개짜리 배열일 수도 있고, 알 수가 없다.

만약 리스트 길이를 출력하면 뭐가 나올까?

`print(len(int_list)) # 6`

실제 사용하고 있는 메모리 공간이 더 많을지라도, 파이썬은 개수를 셀 때 값을 저장해 놓은 공간에 대해서만 알려준다. 그래서 우리는 나머지 공간에 대해서 전혀 신경을 안 써도 된다.

만약 채워지지 않은 공간에 접근하려고 하면

`print(int_list[9])`

오류가 난다. 우리가 미리 값을 저장해 놓은 공간에만 접근할 수 있도록 파이썬이 미리 처리를 해 놓은 것임

파이썬 뿐만 아니라 **동적 배열**을 자료형으로 제공한느 대부분의 언어들은 이렇게 실제 사용하는 배열의 크기와 상관 없이 **저장해 놓은 공간만 사용할 수 있게** 처리해줌

  </details>
  <details>
    <summary>동적 배열 추가 연산 시간 복잡도</summary>

# 동적 배열 추가 연산 시간 복잡도

## 추가 연산 (append operation)

### 경우 1: 정적 배열에 남는 공간 있을 때

그냥 비어있는 공간 중에 가장 앞 쪽에 있는 곳에 데이터를 저장하면 됨

시간복잡도: O(1)

### 경우 2: 정적 배열이 꽉 찼을 때

1. 값을 복사하기 위해서 현재 사용 중인 공간보다 2배로 큰 메모리 공간 예약
2. 기존 배열에서 새로운 배열로 값을 싹 다 복사: O(n)
3. 빈 칸에 새로운 값을 추가: O(1)

시간복잡도: O(n)

### 동적 배열 추가 연산 시간 복잡도

최고의 경우: O(1)

최악의 경우: O(n)

  </details>
  <details>
    <summary>분활 상환 분석 개념 & 적용</summary>

# 분활 상환 분석 개념

동적 배열 추가 연산을 할 때 최고의 경우(빈 공간O)는 자주 일어나며, 최악의 경우(빈 공간X)는 가끔 일어남

따라서 최악의 경우인 O(n)으로 시간 복잡도를 계산하는 것은 조금 비합리적인 것으로 보임

보통 시간 복잡도는 최악의 경우로 말하는데, 지금처럼 그것이 비합리적인 상황들이 종종 있음

이런 상황에 쓰이는, 시간 복잡도를 다르게 계산하는 방법들이 있음

## 분활 상환 분석 (Amortized Analysis)

- 같은 동작을 n번 했을 때 드는 시간이 X일 때: 동작을 한 번 하는 데 걸린 시간 = X / n

# 분활 상환 분석 적용

## 동적 배열 추가 연산

1. 새로운 인덱스에 데이터를 저장하는 시간
2. 기존 배열의 크기가 부족해서 더 큰 배열을 만들고, 기존 배열의 데이터들을 옮기는 시간

## 분할 상환 분석

동적 배열 추가 연산을 n번 반복한다고 가정.

총 시간을 계산하기 쉽게 두 가지로 나눠서 생각

1. 새로운 데이터를 동적 배열 맨 끝에 단순히 저장하는 데 걸리는 시간
2. 더 큰 배열을 만들고 그 배열에 기존의 데이터를 옮기는 데 걸리는 시간

### 배열 끝에 새로운 데이터를 저장하는 데 걸리는 시간

인덱스에 데이터를 저장하는 데 걸리는 시간은 1.

이걸 총 n번 하는 거니까 O(n)이 걸림

### 새로운 배열에 데이터를 옮기는 시간

내부 배열이 꽉 차서 데이터를 복사하는 데 걸리는 시간.

1칸 짜리 배열부터 시작하고, 배열이 꽉 찰 때마다 배열의 크기를 2배로 늘린다고 가정

2번째, 3번째, 5번째, 9번째 추가 때 배열의 크기를 늘려야 함. 그럴 때마다 데이터를 옮겨야 함

이때 데이터를 각각 1, 2, 4, 8개씩 복사하고 붙여넣음

→ 데이터를 복사해서 붙여 넣는 총 시간 비용은 이 시간들을 더한 8+4+2+1

**좀 더 일반화해서 생각**

추가 연산은 n번 했을 때, 가장 마지막에 데이터를 m개 옮겨서 저장했다고 가정

데이터를 복사해서 저장하는 데 걸린 총 시간은: m + m/2 + m/4 + ... + 1

어느 자연수 m이든 반씩 줄여서 1까지 계속 더해주면 그 결과는 절대 2m을 넘을 수 없음

결과는 _2m-1_ 이 됨

추가 연산을 연속으로 n번 하고, 가장 마지막에 옮겨 저장한 데이터 요소 수를 m이라고 할 때:

- 복사해서 저장하는 데 걸린 총 시간이 2m-1 이고
- m은 n보다 작다

다시 정리하면,

> 연속으로 추가 연산을 n번을 하면 데이터를 옮겨서 저장하는 데 걸리는 총 시간은 2n보다 작다!

## 두 경우 합치기

종합하면, 동적 배열에 n개의 데이터를 연속으로 추가하면:

1. 새로운 데이터를 저장하는 데에는 n의 시간이 들고
2. 데이터를 옮겨 저장하는 데에는 2n보다 적은 시간이 듦

이 두 시간을 합치면 총 드는 시간은 3n보다 적은 시간. 시간 복잡도로 표현하면 O(3n),

즉 O(n)임

근데 이것은 추가 연산을 한 번 하는 게 아니라 연속으로 n번 하는 데 걸리는 시간 복잡도임

따라서 뻔 하는 데는 O(n) / n, 즉 O(1)이 걸리는 것

전에는 추가 연산이 최악의 경우 O(n)이 걸린다고 했는데, 분할 상환 분석을 하면 O(1)이 걸린다고 보는 것

## 최악의 경우 분석 vs. 분할 상환 분석

분할 상환 분석을 한다고 꼭 시간 복잡도가 줄어드는 건 아님 보통은 할부 개념을 적용해도 시간 복잡도가 줄어들지 않음

하지만 만약 최악의 경우보다 분할 상환 분석을 한 시간 복잡도가 더 적다면, 분할 상환 분석을 한 시간 복잡도를 사용함

"동적 배열의 끝에 데이털르 추가할 때는 O(1)이 걸린다" 라고 표현해도 된다는 것

좀 더 정확하게 표현하자면,

> 동적 배열의 추가 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸린다.

  </details>

  <details>
    <summary>동적 배열 삽입 연산</summary>

# 동적 배열 삽입 연산

추가(append) - 맨 끝에 넣을 때

삽입(insertion) - 배열의 아무 위치에나 넣을 때

## 삽입 연산(insert operation)

- 경우 1: 정적 배열에 남는 공간이 있을 때
- 경우 2: 정적 배열이 꽉 찼을 때

### 정적 배열에 여유 공간이 있을 때

넣으려고 하는 인덱스 이후의 모든 데이터를 한 칸씩 뒤로 밀어주어야 함(한 칸 뒤의 인덱스에 저장)

최악의 경우 시간 복잡도: O(n)

### 정적 배열이 꽉 찼을 때

새로운 배열에 요소들을 복사할 때 O(n) + 원하는 인덱스에 자리를 마련할 때 O(n) + 인덱스에 데이터를 저장할 때 O(1) = O(2n+1)

즉, O(n)

## 종합

가능한 두 경우 모두 시간 복잡도가 O(n)이므로,

삽입 연산의 시간 복잡도: O(n)

  </details>
  <details>
    <summary>동적 배열 삭제 연산</summary>

# 동적 배열 삭제 연산

## 삭제 연산

1. 삭제를 원하는 인덱스 뒤에 있는 데이터를 모두 한 칸씩 앞으로 밀어서 저장
2. 데이터를 삭제했으니까 동적 배열에서 접근할 수 있는 인덱스 범위도 1 감소시킴

요약하면, 삭제 연산은 그냥 삭제하고 싶은 데이터 뒤에 있는 모든 데이터 요소들을 한 칸씩 앞으로 밀어서 저장하면 됨

## 시간 복잡도

### 맨 앞의 데이터를 지울 때 (최악의 경우)

인덱스 1부터 끝까지 모든 요소들을 한 칸씩 앞으로 밀어서 저장해야 됨.

n - 1 개의 요소들을 하나씩 앞 칸으로 밀어서 저장

이 횟수가 n에 비례하기 때문에 시간 복잡도는 **O(n)**

### 맨 뒤 데이터를 지울 때

맨 뒤 데이터를 삭제할 때는 아무 요소를 안 밀고 저장해도 되고, 그냥 동적 배열의 사용 공간을 한 인덱스 줄이면 됨

이건 배열에 데이터 요소가 몇 개 있는지에 상관 없이 일정한 시간에 할 수 있음

따라서 시간 복잡도는 **O(1)**

## 정리

동적 배열의 임의의 위치에 있는 데이터를 삭제할 때는 원하는 위치 뒤에 있는 데이터를 옮겨 저장해야 하기 때문에 최악의 경우 O(n)이 걸림

하지만 가장 뒤에 있는 데이터를 삭제할 때는 다른 데이터를 옮겨 저장할 필요가 없기 때문에 O(1)이 걸림

  </details>
  <details>
    <summary>동적 배열 크기 줄이기</summary>

# 동적 배열 크기 줄이기

동적 배열은 내부적으로 정해진 크기의 정적 배열을 사용하고 있음

값을 추가하다가 내부 배열이 꽉 차면 더 큰 내부 배열을 사용하도록 자동으로 늘려 줌

반대로, 삭제를 할 때에는 내부 배열의 크기를 줄이기도 함

## 왜 내부 배열의 크기를 줄여야 될까?

만약 데이터 요소 10000개 있는 동적 배열에서 요소 9900개를 삭제하면 되면 100개만 남게 되는데, 그러면 나머지 9900개의 요소를 저장할 수 있는 낭비될 것임

동적 배열은 요소의 개수가 어느 정도 줄어들면 내부 배열의 크기도 적절히 줄여서 **공간을 좀 더 효율적으로 사용**함

## 내부 배열의 크기는 어떻게 줄어들까?

동적 배열의 요소 삭제 후 정확히 어떤 시점에 배열의 크기를 줄이면 좋을까?

크기를 늘릴 때는 내부 배열이 꽉 찼을 때였는데, 크기를 줄일 때는 내부 배열의 사용 비율이 특정 값 이하로 떨어질 때임

이 비율이 **1/3** 이라고 가정해보자. 또, 크기가 9인 배열에서 요소가 4개에서 3개로 줄어든 상황을 가정해보자.

총 사용할 수 있는 공간 중 1/3 밖에 사용을 안 하고 있는 것임. 이때:

1. 크기가 3인 새로운 내부 배열을 정의한다.
2. 기존의 3개 요소를 새로 만든 내부 배열에 옮겨서 저장한다.

전에는 6칸을 낭비하고 있었는데 이제는 낭비하고 있는 공간이 하나도 없음. 내부 배열의 크기를 요소 수에 맞게 줄이면, 낭비하는 공간을 최소한으로 할 수 있음

배열의 크기를 줄이는 사용 비율의 기준은 개발자나 프로그래밍 언어에 따라 다르다.

일단 생각의 편의를 위해 배열의 크기를 늘릴 때는 2배로 늘리고, 줄일 때에는 **요소 수가 배열 크기의 1/2가 됐을 때 줄인다고 가정**하자.

## 시간 복잡도

### 동적 배열 맨 끝 데이터 삭제 시간 복잡도

최악의 경우: 더 작은 배열로 모든 요소들을 옮겨 저장해야 될 때

- 총 n개의 데이터를 모두 새 배열에 복사해서 넣어야 함
- 맨 뒤 데이터 삭제: O(1)
- n개의 데이터를 모두 새 배열에 복사: O(n)
- 시간 복잡도: O(n)

### 맨 끝 데이터 삭제 분활 상환 분석

하지만 내부 배열의 크기가 줄어드는 건 드문 경우임. 대부분의 경우 그냥 마지막 인덱스에 있는 데이터를 지워 주기만 하면 됨

동적 배열에서 마지막 데이터를 삭제할 때는 대부분의 경우 O(1)이 걸리지만, 드물게 O(n)이 걸림

그렇기 때문에 추가 연산과 마찬가지로 분할 상환 분석을 적용할 수 있음

분할 상환 분석을 적용하면 맨 끝 데이터 삭제 연산도 O(1)이 걸린다고 이야기할 수 있음

## 정리

> 동적 배열에서 맨 끝 데이터를 삭제하는 연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 적용하면 O(1)이라고 할 수 있다.

  </details>
  <details>
    <summary>배열과 동적 배열 정리/비교</summary>

# 배열과 동적 배열 정리/비교

## 연산 & 시간 복잡도

### (정적) 배열

- 접근 (access): O(1)
- 탐색 (search): O(n)
- 삽입 (insert): Not Available
- 삭제 (delete): Not Available

### 동적 배열

- 접근 (access): O(1)
- 탐색 (search): O(n)
- 삽입 (insert): O(n), 맨 뒤 O(1)
- 삭제 (delete): O(n), 맨 뒤 O(1)

## 낭비하는 공간

### (정적) 배열

크기가 고정되어 있기 때문에 낭비하는 공간이 없다!

### 동적 배열

공간을 낭비할 수도 있고 안 할 수도 있다!

최악의 경우

- 저장된 요소 수: n
- 낭비되는 공간: n - 2

최소 0 ~ 최대 n - 2

낭비하는 공간: O(n - 2) = **O(n)**

  </details>
  <details>
    <summary>정적 배열에 삽입과 삭제를 못 하는 이유</summary>

# 정적 배열에 삽입과 삭제를 못 하는 이유

## 배열에 데이터 삽입을 못 하는 이유

배열은 크기가 정해져 있음. 더 많은 데이터 요소들을 저장하고 싶으면 더 큰 배열을 정의해야 함.

사용하고 싶은 요소 수에 따라 크기를 바꿀 수 있으면 그건 배열이 아니라 동적 배열일 것임

크기가 고정되어 있는 배열에는 처음 정한 수보다 더 많은 데이터를 삽입할 수 없는 것

## 배열에 데이터 삭제를 못 하는 이유

정수 4개를 담을 수 있는 배열에 2, 3, 5, 7이 저장되어 있다고 가정하자. 여기서 인덱스 1에 있는 3을 지우고 싶으면 어떻게 하면 될까?

동적 배열 삭제 연산처럼 인덱스 1 자리에 인덱스 2의 데이터를 저장하고, 인덱스 2에 인덱스 3 데이터를 저장해서 2, 5, 7, 7 이렇게 하면 될까?

여기서 문제는 인덱스 3에 저장되어 있던 7을 메모리에서 자연스럽게 지울 수 있는 방법이 마땅히 없다는 것이다.

비었다는 것을 표시하기 위해서 파이썬에서는 None, 다른 언어들에서는 Null 이런 값을 넣는 방법을 생각할 수도 있다. 그런데 우리가 C에서 정의한 정수형 자료가 들어가는 배열에 None이나 Null은 정수형이 아니기 때문에 저장할 수 없다.

정리하자면 배열에서 인덱스 1을 지우기 위해서는 2, 3, 5, 7의 데이터를 2, 5, 7으로 만드는 게 아니라, 2, 5, 7, 7 이런 식으로 밖에 못 만든다.

지우고 싶은 요소를 "자연스럽게" 삭제할 수는 없는 것이다.

### 비교: 동적 배열에서의 삭제

많은 언어들 자체적으로 제공하는 동적 배열은 사용하는 배열의 크기와 사용하는 인덱스 범위를 따로 처리한다.

동적 배열이 내부적으로 정수 4개를 저장할 수 있는 배열에 2, 3, 5, 7을 저장하고 있다고 가정하자.

동적 배열에서 인덱스 1을 삭제하고 싶으면 인덱스 1에 5를 저장하고, 인덱스 2에 7을 저장한다. 그럼 내부적으로는 2, 5, 7, 7 이렇게 저장되어 있을텐데,

그 다음에 인덱스 3에 있는 7을 지우는 게 아니라 파이썬 내부적으로 개발자가 접근할 수 있는 인덱스 범위를 0 ~ 2로 만들어 버린다. 더 이상 인덱스 3에 접근할 수 없게 만드는 것

실제로 인덱스 3에 어떤 값이 저장되어 있든 상관 없이 개발자는 더 이상 거기 접근할 수 없다. 동적 배열에서 접근할 수 있는 데이터가 2, 5, 7 밖에 없으니까 실질적으로 삭제되었다고 할 수 있는 것.

  </details>

</details>

<details>
  <summary>3) 링크드 리스트</summary>

</details>

<details>
  <summary>4) 해시 테이블</summary>

</details>

<details>
  <summary>5) 추상 자료형</summary>

</details>
